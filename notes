binaries -

egen - randomly generate an election
    stdin = <none>

    flags
    -cand=3: Number of candidates in election
    -cond=false: Force condorcet winner
    -fix=false: Use fixed random seed
    -peak=false: Force generation with peak preference
    -pref=false: Force preference of some candidate
    -rand=false: Use a random vote/cand count
    -vote=6: Number of voters in election

    stdout: vote matrix json
    {
        "votes":
        [
            {
                "peak": 0,
                "vote": {
                    "0": 0
                    "1": 2,
                    "2": 1,
                }
            },
            {
                ...
            },
        ],

        "peak": true,
        "pref": {
            "b": 1,
            "a": 2
        }
        "rank": [ 4, 3, 5, 0, 0, 0 ],
        "condorcet": 2,
        "candidates": 3
    }

tally - tallies election results
    flags
    - type = [string: slater, kemeny, bucklin, second order copeland, STV, borda, all] default: all. Election types to tally
    slater = minimum lines swapped
    kemeny = minimum weight swapped

    - output
    {
        "slater": ["4", "2", "3", "1"], //order is implicit - "4" is rank 1, "2" is rank 2, ...
        "kemeny": ["4", "2", "3", "1"],
        "condorcet": "4",
        ...
    }

report - pretty print election results
    stdin = newline separated election results (json)

    flags
    - type = [string] (csv, viz, table)

possible binaries for part II
    -compare results
    -condorcet winner is not the winner
    -remove (irrelevant?) candidate from election
    -find manipulation
    -find single peaked preferences
